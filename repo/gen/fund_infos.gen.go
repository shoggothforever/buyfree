// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"buyfree/repo/model"
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFundInfo(db *gorm.DB, opts ...gen.DOOption) fundInfo {
	_fundInfo := fundInfo{}

	_fundInfo.fundInfoDo.UseDB(db, opts...)
	_fundInfo.fundInfoDo.UseModel(&model.FundInfo{})

	tableName := _fundInfo.fundInfoDo.TableName()
	_fundInfo.ALL = field.NewAsterisk(tableName)
	_fundInfo.UserID = field.NewInt64(tableName, "user_id")
	_fundInfo.CardID = field.NewInt64(tableName, "card_id")
	_fundInfo.BankName = field.NewString(tableName, "bank_name")
	_fundInfo.Cash = field.NewFloat64(tableName, "cash")
	_fundInfo.BankFund = field.NewFloat64(tableName, "bank_fund")

	_fundInfo.fillFieldMap()

	return _fundInfo
}

type fundInfo struct {
	fundInfoDo

	ALL      field.Asterisk
	UserID   field.Int64
	CardID   field.Int64
	BankName field.String
	Cash     field.Float64
	BankFund field.Float64

	fieldMap map[string]field.Expr
}

func (f fundInfo) Table(newTableName string) *fundInfo {
	f.fundInfoDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f fundInfo) As(alias string) *fundInfo {
	f.fundInfoDo.DO = *(f.fundInfoDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *fundInfo) updateTableName(table string) *fundInfo {
	f.ALL = field.NewAsterisk(table)
	f.UserID = field.NewInt64(table, "user_id")
	f.CardID = field.NewInt64(table, "card_id")
	f.BankName = field.NewString(table, "bank_name")
	f.Cash = field.NewFloat64(table, "cash")
	f.BankFund = field.NewFloat64(table, "bank_fund")

	f.fillFieldMap()

	return f
}

func (f *fundInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *fundInfo) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 5)
	f.fieldMap["user_id"] = f.UserID
	f.fieldMap["card_id"] = f.CardID
	f.fieldMap["bank_name"] = f.BankName
	f.fieldMap["cash"] = f.Cash
	f.fieldMap["bank_fund"] = f.BankFund
}

func (f fundInfo) clone(db *gorm.DB) fundInfo {
	f.fundInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f fundInfo) replaceDB(db *gorm.DB) fundInfo {
	f.fundInfoDo.ReplaceDB(db)
	return f
}

type fundInfoDo struct{ gen.DO }

type IFundInfoDo interface {
	gen.SubQuery
	Debug() IFundInfoDo
	WithContext(ctx context.Context) IFundInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFundInfoDo
	WriteDB() IFundInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFundInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFundInfoDo
	Not(conds ...gen.Condition) IFundInfoDo
	Or(conds ...gen.Condition) IFundInfoDo
	Select(conds ...field.Expr) IFundInfoDo
	Where(conds ...gen.Condition) IFundInfoDo
	Order(conds ...field.Expr) IFundInfoDo
	Distinct(cols ...field.Expr) IFundInfoDo
	Omit(cols ...field.Expr) IFundInfoDo
	Join(table schema.Tabler, on ...field.Expr) IFundInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFundInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFundInfoDo
	Group(cols ...field.Expr) IFundInfoDo
	Having(conds ...gen.Condition) IFundInfoDo
	Limit(limit int) IFundInfoDo
	Offset(offset int) IFundInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFundInfoDo
	Unscoped() IFundInfoDo
	Create(values ...*model.FundInfo) error
	CreateInBatches(values []*model.FundInfo, batchSize int) error
	Save(values ...*model.FundInfo) error
	First() (*model.FundInfo, error)
	Take() (*model.FundInfo, error)
	Last() (*model.FundInfo, error)
	Find() ([]*model.FundInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FundInfo, err error)
	FindInBatches(result *[]*model.FundInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FundInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFundInfoDo
	Assign(attrs ...field.AssignExpr) IFundInfoDo
	Joins(fields ...field.RelationField) IFundInfoDo
	Preload(fields ...field.RelationField) IFundInfoDo
	FirstOrInit() (*model.FundInfo, error)
	FirstOrCreate() (*model.FundInfo, error)
	FindByPage(offset int, limit int) (result []*model.FundInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFundInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	GetByID(id int64) (result model.FundInfo, err error)
	GetByName(name string) (result model.FundInfo, err error)
}

// SELECT * FROM @@table WHERE id=@id
func (f fundInfoDo) GetByID(id int64) (result model.FundInfo, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM fund_infos WHERE id=? ")

	var executeSQL *gorm.DB
	executeSQL = f.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE name=@name
func (f fundInfoDo) GetByName(name string) (result model.FundInfo, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, name)
	generateSQL.WriteString("SELECT * FROM fund_infos WHERE name=? ")

	var executeSQL *gorm.DB
	executeSQL = f.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (f fundInfoDo) Debug() IFundInfoDo {
	return f.withDO(f.DO.Debug())
}

func (f fundInfoDo) WithContext(ctx context.Context) IFundInfoDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f fundInfoDo) ReadDB() IFundInfoDo {
	return f.Clauses(dbresolver.Read)
}

func (f fundInfoDo) WriteDB() IFundInfoDo {
	return f.Clauses(dbresolver.Write)
}

func (f fundInfoDo) Session(config *gorm.Session) IFundInfoDo {
	return f.withDO(f.DO.Session(config))
}

func (f fundInfoDo) Clauses(conds ...clause.Expression) IFundInfoDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f fundInfoDo) Returning(value interface{}, columns ...string) IFundInfoDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f fundInfoDo) Not(conds ...gen.Condition) IFundInfoDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f fundInfoDo) Or(conds ...gen.Condition) IFundInfoDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f fundInfoDo) Select(conds ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f fundInfoDo) Where(conds ...gen.Condition) IFundInfoDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f fundInfoDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IFundInfoDo {
	return f.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (f fundInfoDo) Order(conds ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f fundInfoDo) Distinct(cols ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f fundInfoDo) Omit(cols ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f fundInfoDo) Join(table schema.Tabler, on ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f fundInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f fundInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f fundInfoDo) Group(cols ...field.Expr) IFundInfoDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f fundInfoDo) Having(conds ...gen.Condition) IFundInfoDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f fundInfoDo) Limit(limit int) IFundInfoDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f fundInfoDo) Offset(offset int) IFundInfoDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f fundInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFundInfoDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f fundInfoDo) Unscoped() IFundInfoDo {
	return f.withDO(f.DO.Unscoped())
}

func (f fundInfoDo) Create(values ...*model.FundInfo) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f fundInfoDo) CreateInBatches(values []*model.FundInfo, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f fundInfoDo) Save(values ...*model.FundInfo) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f fundInfoDo) First() (*model.FundInfo, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FundInfo), nil
	}
}

func (f fundInfoDo) Take() (*model.FundInfo, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FundInfo), nil
	}
}

func (f fundInfoDo) Last() (*model.FundInfo, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FundInfo), nil
	}
}

func (f fundInfoDo) Find() ([]*model.FundInfo, error) {
	result, err := f.DO.Find()
	return result.([]*model.FundInfo), err
}

func (f fundInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FundInfo, err error) {
	buf := make([]*model.FundInfo, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f fundInfoDo) FindInBatches(result *[]*model.FundInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f fundInfoDo) Attrs(attrs ...field.AssignExpr) IFundInfoDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f fundInfoDo) Assign(attrs ...field.AssignExpr) IFundInfoDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f fundInfoDo) Joins(fields ...field.RelationField) IFundInfoDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f fundInfoDo) Preload(fields ...field.RelationField) IFundInfoDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f fundInfoDo) FirstOrInit() (*model.FundInfo, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FundInfo), nil
	}
}

func (f fundInfoDo) FirstOrCreate() (*model.FundInfo, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FundInfo), nil
	}
}

func (f fundInfoDo) FindByPage(offset int, limit int) (result []*model.FundInfo, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f fundInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f fundInfoDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f fundInfoDo) Delete(models ...*model.FundInfo) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *fundInfoDo) withDO(do gen.Dao) *fundInfoDo {
	f.DO = *do.(*gen.DO)
	return f
}
