// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"buyfree/repo/model"
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newDriverCart(db *gorm.DB, opts ...gen.DOOption) driverCart {
	_driverCart := driverCart{}

	_driverCart.driverCartDo.UseDB(db, opts...)
	_driverCart.driverCartDo.UseModel(&model.DriverCart{})

	tableName := _driverCart.driverCartDo.TableName()
	_driverCart.ALL = field.NewAsterisk(tableName)
	_driverCart.DriverID = field.NewString(tableName, "driver_id")
	_driverCart.FactoryName = field.NewString(tableName, "factory_name")
	_driverCart.Distance = field.NewInt64(tableName, "distance")
	_driverCart.CartID = field.NewInt64(tableName, "cart_id")
	_driverCart.TotalCount = field.NewInt64(tableName, "total_count")
	_driverCart.TotalAmount = field.NewFloat64(tableName, "total_amount")
	_driverCart.Products = driverCartHasManyProducts{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Products", "model.OrderProduct"),
	}

	_driverCart.fillFieldMap()

	return _driverCart
}

type driverCart struct {
	driverCartDo

	ALL         field.Asterisk
	DriverID    field.String
	FactoryName field.String
	Distance    field.Int64
	CartID      field.Int64
	TotalCount  field.Int64
	TotalAmount field.Float64
	Products    driverCartHasManyProducts

	fieldMap map[string]field.Expr
}

func (d driverCart) Table(newTableName string) *driverCart {
	d.driverCartDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d driverCart) As(alias string) *driverCart {
	d.driverCartDo.DO = *(d.driverCartDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *driverCart) updateTableName(table string) *driverCart {
	d.ALL = field.NewAsterisk(table)
	d.DriverID = field.NewString(table, "driver_id")
	d.FactoryName = field.NewString(table, "factory_name")
	d.Distance = field.NewInt64(table, "distance")
	d.CartID = field.NewInt64(table, "cart_id")
	d.TotalCount = field.NewInt64(table, "total_count")
	d.TotalAmount = field.NewFloat64(table, "total_amount")

	d.fillFieldMap()

	return d
}

func (d *driverCart) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *driverCart) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 7)
	d.fieldMap["driver_id"] = d.DriverID
	d.fieldMap["factory_name"] = d.FactoryName
	d.fieldMap["distance"] = d.Distance
	d.fieldMap["cart_id"] = d.CartID
	d.fieldMap["total_count"] = d.TotalCount
	d.fieldMap["total_amount"] = d.TotalAmount

}

func (d driverCart) clone(db *gorm.DB) driverCart {
	d.driverCartDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d driverCart) replaceDB(db *gorm.DB) driverCart {
	d.driverCartDo.ReplaceDB(db)
	return d
}

type driverCartHasManyProducts struct {
	db *gorm.DB

	field.RelationField
}

func (a driverCartHasManyProducts) Where(conds ...field.Expr) *driverCartHasManyProducts {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a driverCartHasManyProducts) WithContext(ctx context.Context) *driverCartHasManyProducts {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a driverCartHasManyProducts) Model(m *model.DriverCart) *driverCartHasManyProductsTx {
	return &driverCartHasManyProductsTx{a.db.Model(m).Association(a.Name())}
}

type driverCartHasManyProductsTx struct{ tx *gorm.Association }

func (a driverCartHasManyProductsTx) Find() (result []*model.OrderProduct, err error) {
	return result, a.tx.Find(&result)
}

func (a driverCartHasManyProductsTx) Append(values ...*model.OrderProduct) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a driverCartHasManyProductsTx) Replace(values ...*model.OrderProduct) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a driverCartHasManyProductsTx) Delete(values ...*model.OrderProduct) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a driverCartHasManyProductsTx) Clear() error {
	return a.tx.Clear()
}

func (a driverCartHasManyProductsTx) Count() int64 {
	return a.tx.Count()
}

type driverCartDo struct{ gen.DO }

type IDriverCartDo interface {
	gen.SubQuery
	Debug() IDriverCartDo
	WithContext(ctx context.Context) IDriverCartDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDriverCartDo
	WriteDB() IDriverCartDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDriverCartDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDriverCartDo
	Not(conds ...gen.Condition) IDriverCartDo
	Or(conds ...gen.Condition) IDriverCartDo
	Select(conds ...field.Expr) IDriverCartDo
	Where(conds ...gen.Condition) IDriverCartDo
	Order(conds ...field.Expr) IDriverCartDo
	Distinct(cols ...field.Expr) IDriverCartDo
	Omit(cols ...field.Expr) IDriverCartDo
	Join(table schema.Tabler, on ...field.Expr) IDriverCartDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDriverCartDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDriverCartDo
	Group(cols ...field.Expr) IDriverCartDo
	Having(conds ...gen.Condition) IDriverCartDo
	Limit(limit int) IDriverCartDo
	Offset(offset int) IDriverCartDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDriverCartDo
	Unscoped() IDriverCartDo
	Create(values ...*model.DriverCart) error
	CreateInBatches(values []*model.DriverCart, batchSize int) error
	Save(values ...*model.DriverCart) error
	First() (*model.DriverCart, error)
	Take() (*model.DriverCart, error)
	Last() (*model.DriverCart, error)
	Find() ([]*model.DriverCart, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DriverCart, err error)
	FindInBatches(result *[]*model.DriverCart, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DriverCart) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDriverCartDo
	Assign(attrs ...field.AssignExpr) IDriverCartDo
	Joins(fields ...field.RelationField) IDriverCartDo
	Preload(fields ...field.RelationField) IDriverCartDo
	FirstOrInit() (*model.DriverCart, error)
	FirstOrCreate() (*model.DriverCart, error)
	FindByPage(offset int, limit int) (result []*model.DriverCart, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDriverCartDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	GetByCardID(id int64) (result model.DriverCart, err error)
	GetAllCarts(driverid int64) (result []model.DriverCart, err error)
}

// SELECT * FROM @@table WHERE cart_id=@id
func (d driverCartDo) GetByCardID(id int64) (result model.DriverCart, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM driver_carts WHERE cart_id=? ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// sql(SELECT * FROM @@table where @driverid=(SELECT id from drivers where id =@driverid))
func (d driverCartDo) GetAllCarts(driverid int64) (result []model.DriverCart, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, driverid)
	params = append(params, driverid)
	generateSQL.WriteString("SELECT * FROM driver_carts where ?=(SELECT id from drivers where id =?) ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (d driverCartDo) Debug() IDriverCartDo {
	return d.withDO(d.DO.Debug())
}

func (d driverCartDo) WithContext(ctx context.Context) IDriverCartDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d driverCartDo) ReadDB() IDriverCartDo {
	return d.Clauses(dbresolver.Read)
}

func (d driverCartDo) WriteDB() IDriverCartDo {
	return d.Clauses(dbresolver.Write)
}

func (d driverCartDo) Session(config *gorm.Session) IDriverCartDo {
	return d.withDO(d.DO.Session(config))
}

func (d driverCartDo) Clauses(conds ...clause.Expression) IDriverCartDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d driverCartDo) Returning(value interface{}, columns ...string) IDriverCartDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d driverCartDo) Not(conds ...gen.Condition) IDriverCartDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d driverCartDo) Or(conds ...gen.Condition) IDriverCartDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d driverCartDo) Select(conds ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d driverCartDo) Where(conds ...gen.Condition) IDriverCartDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d driverCartDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDriverCartDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d driverCartDo) Order(conds ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d driverCartDo) Distinct(cols ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d driverCartDo) Omit(cols ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d driverCartDo) Join(table schema.Tabler, on ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d driverCartDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d driverCartDo) RightJoin(table schema.Tabler, on ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d driverCartDo) Group(cols ...field.Expr) IDriverCartDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d driverCartDo) Having(conds ...gen.Condition) IDriverCartDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d driverCartDo) Limit(limit int) IDriverCartDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d driverCartDo) Offset(offset int) IDriverCartDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d driverCartDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDriverCartDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d driverCartDo) Unscoped() IDriverCartDo {
	return d.withDO(d.DO.Unscoped())
}

func (d driverCartDo) Create(values ...*model.DriverCart) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d driverCartDo) CreateInBatches(values []*model.DriverCart, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d driverCartDo) Save(values ...*model.DriverCart) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d driverCartDo) First() (*model.DriverCart, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DriverCart), nil
	}
}

func (d driverCartDo) Take() (*model.DriverCart, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DriverCart), nil
	}
}

func (d driverCartDo) Last() (*model.DriverCart, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DriverCart), nil
	}
}

func (d driverCartDo) Find() ([]*model.DriverCart, error) {
	result, err := d.DO.Find()
	return result.([]*model.DriverCart), err
}

func (d driverCartDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DriverCart, err error) {
	buf := make([]*model.DriverCart, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d driverCartDo) FindInBatches(result *[]*model.DriverCart, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d driverCartDo) Attrs(attrs ...field.AssignExpr) IDriverCartDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d driverCartDo) Assign(attrs ...field.AssignExpr) IDriverCartDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d driverCartDo) Joins(fields ...field.RelationField) IDriverCartDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d driverCartDo) Preload(fields ...field.RelationField) IDriverCartDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d driverCartDo) FirstOrInit() (*model.DriverCart, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DriverCart), nil
	}
}

func (d driverCartDo) FirstOrCreate() (*model.DriverCart, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DriverCart), nil
	}
}

func (d driverCartDo) FindByPage(offset int, limit int) (result []*model.DriverCart, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d driverCartDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d driverCartDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d driverCartDo) Delete(models ...*model.DriverCart) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *driverCartDo) withDO(do gen.Dao) *driverCartDo {
	d.DO = *do.(*gen.DO)
	return d
}
